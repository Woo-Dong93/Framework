# 리덕스의 키워드 및 규칙



### 1. 액션(Action)

- 상태에 어떠한 변화가 필요하게 될 땐, 우리는 **액션**이란 것을 발생시킵니다. 이는, 하나의 객체로 표현됩니다.
- 액션 객체는 `type` 필드를 필수적으로 가지고 있어야하고 그 외의 값들은 개발자 마음대로 넣어줄 수 있다.

```js
{
  type: "ADD_TODO",
  data: {
    id: 0,
    text: "리덕스 배우기"
  }
}
```



### 2. 액션 생성자 함수(Action Creator)

- 액션 생성함수는, 액션을 만드는 함수입니다. 단순히 파라미터를 받아와서 액션 객체 형태로 만들어줍니다.
- **리덕스**를 사용 할 때 액션 생성함수를 사용하는것이 필수적이진 않습니다. 액션을 발생 시킬 때마다 직접 액션 객체를 작성할수도 있습니다.

```js
export function addTodo(data) {
  return {
    type: "ADD_TODO",
    data
  };
}

// 화살표 함수로도 만들 수 있습니다.
export const changeInput = text => ({ 
  type: "CHANGE_INPUT",
  text
});
```



### 3. 리듀서(Reducer)

- 변화를 일으키는 함수입니다. 
- 리듀서는 두가지의 파라미터를 받습니다.
- 리듀서는, 현재의 상태와, 전달 받은 액션을 참고하여 새로운 상태를 만들어서 반환합니다.
- `useReducer` 에선 일반적으로 `default:` 부분에 `throw new Error('Unhandled Action')`과 같이 에러를 발생시키도록 처리하는게 일반적인 반면 리덕스의 리듀서에서는 기존 `state`를 그대로 반환하도록 작성해야합니다.
- 리덕스를 사용 할 때에는 여러개의 리듀서를 만들고 이를 합쳐서 루트 리듀서 (Root Reducer)를 만들 수 있습니다.

```js
function counter(state, action) {
  switch (action.type) {
    case 'INCREASE':
      return state + 1;
    case 'DECREASE':
      return state - 1;
    default:
      return state;
  }
}
```



### 4. 스토어 (Store)

- 리덕스에서는 한 애플리케이션당 하나의 **스토어**를 만들게 됩니다. 
- 스토어 안에는, 현재의 앱 **상태**와, 리듀서가 들어가있고, 추가적으로 몇가지 내장 함수들이 있습니다.



### 5. 디스패치 (dispatch)

- **디스패치**는 스토어의 내장함수 중 하나입니다.
- **디스패치**는 액션을 발생 시켜줍니다.
  - `dispatch` 라는 함수에는 액션을 파라미터로 전달합니다.
  - `dispatch(action)` 

- 그렇게 호출을 하면, 스토어는 리듀서 함수를 실행시켜서 해당 액션을 처리하는 로직이 있다면 액션을 참고하여 새로운 상태를 만들어줍니다.



### 6. 구독 (subscribe)

- 구독 또한 스토어의 내장함수 중 하나입니다. 
- `subscribe` 함수는, 함수 형태의 값을 파라미터로 받아옵니다. 
- `subscribe` 함수에 특정 함수를 전달해주면, 액션이 디스패치 되었을 때 마다 전달해준 함수가 호출됩니다.
- 리액트에서 리덕스를 사용하게 될 때 보통 이 함수를 직접 사용하는 일은 별로 없습니다. 
- 그 대신에 `react-redux` 라는 라이브러리에서 제공하는 `connect` 함수 또는 `useSelector` Hook 을 사용하여 리덕스 스토어의 상태에 구독합니다.





## 리덕스의 3가지 규칙



### 1. 하나의 애플리케이션 안에는 하나의 스토어가 있습니다.

- 하나의 애플리케이션에선 단 한개의 스토어를 만들어서 사용합니다. 
- 여러개의 스토어를 사용하는것은 사실 가능하기는 하나, 권장되지는 않습니다. 
- 특정 업데이트가 너무 빈번하게 일어나거나, 애플리케이션의 특정 부분을 완전히 분리시키게 될 때 여러개의 스토어를 만들 수도 있습니다. 
  - 하지만 그렇게 하면, 개발 도구를 활용하지 못하게 됩니다.



### 2. 상태는 읽기전용 입니다.

- 리액트에서 state 를 업데이트 해야 할 때, `setState` 를 사용하고, 배열을 업데이트 해야 할 때는 배열 자체에 push 를 직접 하지 않고, concat 같은 함수를 사용하여 기존의 배열은 수정하지 않고 새로운 배열을 만들어서 교체하는 방식으로 업데이트를 합니다. 
- 엄청 깊은 구조로 되어있는 객체를 업데이트를 할 때도 마찬가지로, 기존의 객체는 건드리지 않고 `Object.assign` 을 사용하거나 spread 연산자 (`...`) 를 사용하여 업데이트 합니다.
- 리덕스에서도 마찬가지로 기존의 상태는 건들이지 않고 새로운 상태를 생성하여 업데이트 해주는 방식으로 해주면, 나중에 개발자 도구를 통해서 뒤로 돌릴 수도 있고 다시 앞으로 돌릴 수도 있습니다.
- 리덕스에서 불변성을 유지해야 하는 이유는 내부적으로 데이터가 변경 되는 것을 감지하기 위하여 [shallow equality](https://redux.js.org/docs/faq/ImmutableData.html#how-redux-uses-shallow-checking) 검사를 하기 때문입니다. 
  - **이를 통하여 객체의 변화를 감지 할 때 객체의 깊숙한 안쪽까지 비교를 하는 것이 아니라 겉핥기 식으로 비교를 하여 좋은 성능을 유지할 수 있는 것이죠.**



### 3. 변화를 일으키는 함수, 리듀서는 순수한 함수여야 합니다.

- 순수한 함수 ( 함수 내의 변수 외에 외부의 값을 참조, 의존하거나 변경하지 않아야 한다. )
  - 리듀서 함수는 이전 상태와, 액션 객체를 파라미터로 받습니다.
  - 이전의 상태는 절대로 건들이지 않고, 변화를 일으킨 새로운 상태 객체를 만들어서 반환합니다.
  - 똑같은 파라미터로 호출된 리듀서 함수는 **언제나** 똑같은 결과값을 반환해야만 합니다.
- 랜덤 숫자를 생성한다던지 혹은, 네트워크에 요청을 한다던지 그러한 작업은 결코 순수하지 않은 작업이므로, 리듀서 함수의 바깥에서 처리해줘야 합니다.
  - 그런것을 하기 위해서, **리덕스 미들웨어**를 사용합니다.

- 순수함수로 만들어야 하는 이유는 Redux의 **변경 감지 알고리즘** 때문입니다.
  - Redux는 reducer를 거친 state가 변경됐는지를 검사하기 위해 state 객체의 주소를 비교합니다.
  - state의 복제본을 만들어 반환하면 이전의 state와 다른 주소값을 가르키기 때문에 state가 변경되었다고 판단합니다.
  - 반대로 state를 복제하는것이 아닌 속성만 수정하여 반환하면 기존의 state 객체와 가리키는 주소값이 같기 때문에 변경감지가 되지 않습니다.